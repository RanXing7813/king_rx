package com.example.demo;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.RowCallbackHandler;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.simple.SimpleJdbcTemplate;
import org.springframework.jdbc.datasource.DriverManagerDataSource;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

import cn.com.king.dto.TestDto;


public class DriverManagerDataSourceTest {

//	url:jdbc:mysql://localhost:3306/yw_taiji?Unicode=true&amp;characterEncoding=utf8
//		driverClassName:com.mysql.jdbc.Driver
	 private static JdbcTemplate jdbcTemplate;  
	 
	 
	    @BeforeClass  
	    public static void setUpClass() {  
	        String url = "jdbc:mysql://localhost:3306/yw_taiji?Unicode=true&amp;characterEncoding=utf8";  
	        String username = "root";  
	        String password = "";  
	        DriverManagerDataSource dataSource = new DriverManagerDataSource(url, username, password);  
	        dataSource.setDriverClassName("com.mysql.jdbc.Driver");  
	        jdbcTemplate = new JdbcTemplate(dataSource);  
	       // 断言  Assert.assertEquals(2, jdbcTemplate.queryForInt("select count(*) from test"));  
	    }  
	    
	    @org.junit.Test 
	    public void test() {  
	    	 
	    	// SimpleJdbcTemplate simpleJdbcTemplate = new SimpleJdbcTemplate(jdbcTemplate);  
	    	 String sql = "select id from test ";  
	       // RowMapper<TestDto> mapper = new UserRowMapper();     
	       // List<TestDto> result2 = simpleJdbcTemplate.query(sql, mapper);    //List<T>
	    	 
	    	 
	    	 //用于自增的主键获取
//	    	    KeyHolder generatedKeyHolder = new GeneratedKeyHolder();  
//	    	    generatedKeyHolder.getKey(); //用于自增的主键获取
//	    	    final String insertSql = "insert into test(name) values('name5')";  
//	    	    jdbcTemplate.update(new PreparedStatementCreator() {  
//	    	        @Override  
//	    	       public PreparedStatement createPreparedStatement(Connection conn)  
//	    	            throws SQLException {  
//	    	            return conn.prepareStatement(insertSql, new String[]{"ID"});  
//	    	      }}, generatedKeyHolder);    
//	    	    generatedKeyHolder.getKey();
//	    	    generatedKeyHolder.getKey();
	    	 //   Assert.assertEquals(4, generatedKeyHolder.getKey());    
	    	    
	        List list =     jdbcTemplate.queryForList(sql);
//	        jdbcTemplate.query(sql, new RowCallbackHandler() {  
//	            @Override  
//	            public void processRow(ResultSet rs) throws SQLException {  
//	                //2.处理结果集  
//	                String value = rs.getString("NAME");  
//	                System.out.println("Column TABLENAME:" + value);  
//	            }  
//	        });  
	        
	        
	    }  
	    
	    
//	    //JdbcTemplate 批处理： 支持普通的批处理及占位符批处理；
//	    @Test  
//	    public void testBatchUpdate1() {  
//	        String insertSql = "insert into test(name) values('name5')";  
//	        String[] batchSql = new String[] {insertSql, insertSql};  
//	        jdbcTemplate.batchUpdate(batchSql);  
//	        Assert.assertEquals(2, jdbcTemplate.queryForInt("select count(*) from test"));  
//	    } 
	    
	    
	    //	           首先读取配置文件，获取IUserDao接口实现，然后再调用IUserDao接口方法，进行数据库操作
	          //，这样对于开发人员使用来说，只面向接口，不关心实现，因此很容易更换实现，比如像更换为hibernate实现非常简单。
//	    @Test  
//	    public void testBestPractice() {  
	   // private static SessionFactory sessionFactory; 
//	        String[] configLocations = new String[] {  
//	                "classpath:chapter7/applicationContext-resources.xml",  
//	                "classpath:chapter7/applicationContext-jdbc.xml"};  
//	        ApplicationContext ctx = new ClassPathXmlApplicationContext(configLocations);  
	   // sessionFactory = ctx.getBean("sessionFactory", SessionFactory.class);  
//	        IUserDao userDao = ctx.getBean(IUserDao.class);  
//	        UserModel model = new UserModel();  
//	        model.setMyName("test");  
//	        userDao.save(model);  
//	         Assert.assertEquals(1, userDao.countAll());  
//	    }  
	    
	    //通过SessionFactory获取Session对象进行创建和删除表：
//	    @Before  
//	    public void setUp() {  
//	      //id自增主键从0开始  
//	      final String createTableSql = "create memory table test" + "(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, " + "name varchar(100))";  
//	      sessionFactory.openSession().  
//	      createSQLQuery(createTableSql).executeUpdate();  
//	    }  
//	    @After  
//	    public void tearDown() {  
//	        final String dropTableSql = "drop table test";  
//	        sessionFactory.openSession().  
//	        createSQLQuery(dropTableSql).executeUpdate();  
//	    } 
	    
//	    8、使用SessionFactory获取Session对象进行持久化数据：	    
//	                     使用SessionFactory获取Session进行操作，必须自己控制事务，而且还要保证各个步骤不会出错，有没有更好的解决方案把我们从编程事务中解脱出来？Spring提供了HibernateTemplate模板类用来简化事务处理和常见操作。
//	    @Test  
//	    public void testFirst() {  
//	        Session session = sessionFactory.openSession();  
//	        Transaction transaction = null;  
//	        try {  
//	            transaction = beginTransaction(session);  
//	            UserModel model = new UserModel();  
//	            model.setMyName("myName");  
//	            session.save(model);  
//	        } catch (RuntimeException e) {  
//	            rollbackTransaction(transaction);  
//	            throw e;  
//	        } finally {  
//	            commitTransaction(session);  
//	        }  
//	    }
//	    
//	    Transaction transaction = session.beginTransaction();  
//		    transaction.begin();  
//		    return transaction;  
//		}  
//		private void rollbackTransaction(Transaction transaction) {  
//		   if(transaction != null) {  
//		        transaction.rollback();  
//		    }  
//		}  
//		private void commitTransaction(Session session) {  
//		    session.close();  
//		} 
	    
	    
//	    8.2.2 使用HibernateTemplate
//	    HibernateTimplate模板类用于简化事务管理及常见操作，类似于JdbcTemplate模板类，对于复杂操作通过提供HibernateCallback回调接口来允许更复杂的操作。
//	     
//	            接下来示例一下HibernateTemplate的使用：
//	    
//        @Test  
//        public void testHibernateTemplate() {  
//        HibernateTemplate hibernateTemplate =  
//        new HibernateTemplate(sessionFactory);  
//            final UserModel model = new UserModel();  
//            model.setMyName("myName");  
//            hibernateTemplate.save(model);  
//            //通过回调允许更复杂操作  
//            hibernateTemplate.execute(new HibernateCallback<Void>() {  
//                @Override  
//                public Void doInHibernate(Session session)  
//                    throws HibernateException, SQLException {  
//                    session.save(model);  
//                    return null;  
//                }});  
//        }       
	            
//	    通过new HibernateTemplate(sessionFactory) 创建HibernateTemplate模板类对象，通过调用模板类的save方法持久化对象，并且自动享受到Spring管理事务的好处。
//	    而且HibernateTemplate 提供使用HibernateCallback回调接口的方法execute用来支持复杂操作，当然也自动享受到Spring管理事务的好处。   
	            
	            
	            
	            
	            
	            
	            
	            
	            
	            
	    public class UserRowMapper implements RowMapper<TestDto> {  
	        @Override  
	        public TestDto mapRow(ResultSet rs, int rowNum) throws SQLException {  
	        	TestDto model = new TestDto();  
	            model.setId(rs.getInt("id"));  
	            model.setName(rs.getString("name"));  
	            return model;  
	        }  
	          
	    }  
	    
	    
	    
	    
	    
	    
}
